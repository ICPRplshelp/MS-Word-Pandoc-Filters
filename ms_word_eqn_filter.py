"""
Pandoc filter to make equations typed in Microsoft Word functional when run with Pandoc.
Normally, when using Pandoc when converting Microsoft Word documents, equations
tend to look a bit off, causing them to not work well. This filter repairs it.

Features:
    - stacked equations will automatically be aligned by the first "=" signs,
      or other similar signs, or +, - if none are present for too long.
    - allows equations to be commented. In Microsoft Word, # is used to make
      flushed-right equation comments. Note that equation comments may
      not contain anything, that if translated into TeX code, would have
      a backslash, except \\text. Please put a number or a phrase - that's
      all you need. Please use "quotation marks" instead of CTRL+I when
      adding textual comments to equations in MS Word.
    - prevents overfull H-boxes. If an equation is too long without a
      line break, it will automatically be broken in half.
    - this filter aims to prevent as many LaTeX errors as possible.
      I've accounted for the errors that could rise.

"""


from panflute import Math, run_filter
from helper_files import helpers as dbl, alignments as w2l


MAX_EQN_LEN = 80  # relative max eqn len.
# About the size of less than a letter paper, horizontally.


def fix_multiline_equations(elem, doc):
    """For multiline equations typeset in Microsoft Word,
    make them aligned.

    Examples:
        {1+2=3}{1+2=3}
        to
        \\begin{aligned}
            1 + 2 &= 3 \\\\
            1 + 2 &= 3 \\\\
        \\end{aligned}
    """
    if type(elem) == Math:
        # text = 'SHUT UP'
        txt = elem.text
        txt = ind_eqn_repairs(txt)
        splitted_eqn = repair_alignments(txt)
        if txt == splitted_eqn and '\\begin{aligned}' not in txt:  # the branch where repairing alignments DIDN'T DO
            splitted_eqn = split_equation(txt)
            elem.text = splitted_eqn
        else:  # the branch where repairing alignments DID SOMETHING
            elem.text = splitted_eqn
        return elem


def repair_alignments(eq: str) -> str:
    """Return text but aligned, or text unchanged if no
    changes are needed.

    Repair multiline equations. Don't
    change anything if the equation isn't multiline.

    What is returned will be the replacement text.

    :param eq: The LaTeX math contents to be fed in.
    Something like {this}{this}{that}

    Preconditions:
        - No right flushing.
    """
    ex_info = {
        'label_equations': False,
        'comment_type': 'align'  # change to tag if needed
    }
    bracket_regions = w2l.bracket_region_outer(eq)
    if len(bracket_regions) == 0:
        return eq  # do nothing; no equations detected
    bracket_state, last = check_valid_bracket_region(eq, bracket_regions)
    if bracket_state == 0:
        return eq  # do nothing
    elif bracket_state == 1:
        lines_1 = [eq[k + 1:v] for k, v in bracket_regions.items()]
    else:
        assert bracket_state == 2
        # lines_1 = [eq[k + 1:v] for k, v in bracket_regions.items()]
        lines_1 = []
        v = 0
        for i, k in enumerate(bracket_regions):
            if i >= last:
                break
            v = bracket_regions[k]
            lines_1.append(eq[k + 1: v])
        # the moment this breaks
        to_append = eq[v + 1:]
        lines_1.append(to_append)
    has_comments = any(dbl.valid_matrix(x) for x in lines_1)
    lines_2 = [w2l.align_expression(line, True, ex_info, has_comments)[0] for line in lines_1]
    output = '\\begin{aligned}\n' + '\\\\\n'.join(lines_2).strip() + '\n\\end{aligned}'
    return output


def check_valid_bracket_region(eq: str, pairs: dict[int, int]) -> tuple[int, int]:
    """Check if the pairs passed in constitutes a proper stacked equation.
    :param eq: the equation to be passed in, which is the same as in repair alignments
    :param pairs: the pairs generated by w2l.bracket_region_outer()
    :return: 0 if FAIL, 1 if PASS NO COMMENT, 2 if PASS HAS COMMENT. Also, last is the index where the loop stops acting
    """
    # condition 1: all the below
    #   condition 2: first char is opening brace {
    #   condition 3: any of the below
    #       condition 4: all closing } must be immediately followed by {
    #       condition 5: the moment condition 4 is broken, at the index,
    #                    whatever remains must be a "valid matrix"
    pair_items = [(k, v) for k, v in pairs.items()]
    pair_items.sort(key=lambda k: k[0])
    prev_index = -1
    for i, pair in enumerate(pair_items):
        st, en = pair
        if i == 0 and st != 0:
            return 0, i   # FAIL
        if prev_index + 1 != st:  # If the index after the previous one isn't an {
            return cvm_short(eq, prev_index + 1), i
        # ONLY OCCURS ON THE LAST LOOP
        if i == len(pair_items) and en != len(eq) - 1:  # If the last closing brace isn't located at the end.
            return 0, i  # cvm_short(eq, en + 1) - This auto-fails because a trailing matrix is impossible
        prev_index = en  # only to occur when a loop increments
    return 1, -1  # all checks pass, by this point.


def cvm_short(eq: str, index: int) -> int:
    """Check valid matrix shorthand
    :param eq: the equation passed into check_valid_bracket_region().
    :param index: the index to start checking the valid matrix. likely prev_index + 1
    :return: 0 if check FAILED, 2 if HAS VALID MATRIX
    """
    to_check = eq[index:]
    if dbl.valid_matrix(to_check):
        return 2
    else:
        return 0


def split_equation(eq: str) -> str:
    """Split the equation if it is too long.

    Preconditions:
        - eq is not already aligned.

    :param eq: The equation content.
    :return: The equation that is split.
    """
    # equation_is_numbered = False
    # starting_index = dbl.find_nth(text, R'\[', skip + 1)
    # finishing_index = dbl.find_nth(text, R'\]', skip + 1)
    # if -1 in (starting_index, finishing_index):
    #     break

    eqn_text = eq
    eqn_comment = ''
    equation_is_numbered = dbl.valid_matrix(eqn_text)
    if equation_is_numbered:
        eqn_text, eqn_comment = dbl.matrix_equation_extractor(eqn_text)
    new_eqn_text = dbl.split_equation(eqn_text, MAX_EQN_LEN, True)

    # THE EQUATION IS SHORT

    if new_eqn_text is None:  # everything is fine - no updates done.
        if equation_is_numbered:
            # wrap the entire equation using the equation environment.
            # equations can be tagged, but labelling isn't supported.
            # I don't even want to support labelling, but I will.
            eqn_label = dbl.get_equation_label(eqn_comment)
            if eqn_label is not None:
                labeling = R' \tag{' + eqn_label + '} '
                labeling += ' \\label{eq:' + eqn_label + '}'
                # equation_labels.append(eqn_label)
                eqn_text += labeling
                return eqn_text
                # no time for wrapping
                # logging.warning(f'equation {eqn_text} has an invalid comment; removing comment.'
                #                 f' Invalid comments are not plain text or numbers.')
        return eqn_text  # otherwise, completely otherwise
        # DO NOT MODIFY EQUATION TEXT
    else:  # otherwise, updates are done, and then we continue.
        # if equation_is_numbered:
        # logging.warning(f'Extra long numbered equation: {eqn_comment}. Comment deleted.')
        # new_eqn_text is just the equation contents without the comments.
        # its type is list[str]
        ex_info = {
            'label_equations': False,
            'comment_type': 'align'  # change to tag if needed
        }
        lines_2 = [w2l.align_expression(line, True, ex_info, False)[0] for line in new_eqn_text]
        output = '\\begin{aligned}\n' + '\\\\\n'.join(lines_2).strip() + '\n\\end{aligned}'
        return output


def ind_eqn_repairs(eq: str) -> str:
    """Repair any equation weirdness.
    :param eq: Equation to pass in.
    :return: Fixed equation.
    """
    eq = w2l.fix_vectors_again(eq)
    eq = dbl.fix_accents(eq)
    eq = dbl.aug_matrix_spacing(eq)
    return eq


def main(doc=None):
    return run_filter(fix_multiline_equations, doc=doc)


if __name__ == "__main__":
    main()
